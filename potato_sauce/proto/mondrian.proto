// Input to the

syntax = "proto3";

import "potato_sauce/proto/geom.proto";

package potato_sauce.mondrian;


enum ThinRectStrategy {
  // Default (currently = subsume)
  THIN_RECT_UNSPECIFIED = 0;
  // Subsume one-pixel-thin rectangles into their surroundings as much as
  // possible.
  THIN_RECT_SUBSUME = 1;
  // Don't do anything about one-pixel-thin rectangles.
  THIN_RECT_IGNORE = 2;
}


// Top-level input to the tessellation generator.
message SceneSpec {
  // Bounding box for the whole scene that will be rendered. The whole thing
  // will come out as one image of this size (which can be split up by a
  // postprocessor later, if necessary.)
  geom.Gridtangle bounding_box = 1;
  // One SceneComponent per distinct "tileset" (more like "color scheme") desired.
  repeated SceneComponent components = 2;
  // A factor by which to scale all rectangles and the bounding box before
  // drawing. If 0, ignored (same effect as factor 1).
  // (This scales everything at once, so you can safely change the value without
  // adjusting any other part of your SceneSpec.)
  int32 scale_by = 3;
  // How one-pixel-thin rectangles should be treated (before scaling, if any).
  ThinRectStrategy thin_rect_strategy = 4;

}

message Color {
  int32 red = 1;
  int32 green = 2;
  int32 blue = 3;
  optional int32 alpha = 4;
}


// Defines where a group of similarly-colored gridtangles should be placed.
message SceneComponent {
  reserved 2;
  // Where to draw.
  // The area defined by `locations` minus `exclude_locations` is guaranteed to
  // be covered by the tessellation. Areas in `exclude_locations` are
  // guaranteed to *not* be covered. Areas in neither may or may not be covered,
  // though all rectangles in the output tessellation will have at least one
  // pixel in `locations`. This means you can have a messy-looking border if you
  // so desire.
  repeated geom.Gridtangle locations = 1;
  // Areas that will *not* be filled with rectangles.
  // Note that although these are grouped with a SceneComponent, they are
  // applied globally to all SceneComponents.
  // TODO: If I start generating more complex tessellations it may behoove me
  // to have a global and local exclude_locations setting. So for example, I
  // could have adjacent areas with a sharp border.
  repeated geom.Gridtangle exclude_locations = 3;
  TilingConfig tiling_config = 4;
}

// How and what to draw, in an unspecified area.
message TilingConfig {
  // Starting with what colors should be used to fill in the rectangles.
  // Each rectangle gets a randomly selected fill color. (Or if there are at
  // least 4 colors, we could color the rectangles so that no like-colored
  // rectangles touch each other. But that's a waste of time when a heuristic
  // will look fine anyhow.)
  repeated Color fill_colors = 3;
  // Color of the single-pixel border around each pixel rectangle.
  Color border_color = 4;
  // TODO: Rectangle size strategy (enum or oneof).
  // Examples:
  //  - Randomly select width and height from range.
  //  - Randomly select height and then choose width for a target area.
  //  - Derp?

  // If true, grey any rectangle not fully contained in the bounding box of the
  // SceneSpec. These rectangles are off-limits in the Tanglemaze game, and
  // this is a good visual cue.
  // (JK It's really ugly, TODO remove)
  bool shade_out_of_bounds = 5;

  // Preferred sizes of rectangle edges (ie width and height of rectangles).
  // There's no guarantee rectangles won't come out in other sizes, since the
  // tessellations are generated by placing rectangles at random until all the
  // space is full.
  // Default: [5, 8, 13, 21, 34]
  repeated int32 edge_sizes = 6;

  // Alternative to edge_sizes, specifying allowable combinations of sizes.
  // Mutually exclusive with edge_sizes.
  repeated RectTargetSize edge_size_combinations = 7;
}

message RectTargetSize {
  int32 width = 1;
  int32 height = 2;
}
